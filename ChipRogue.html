<html>
<canvas id="theCanvas" width="900" height="600" style="border: 1px solid black"></canvas>
<div id="theDiv">
Move with WASD keys.
<br><br>
Perform actions with arrow keys (once you have items loaded).
<br><br>
The right side of the screen lets you manage which items you're using. The top-right shows your "loadouts" - sets of up to four items you can use simultaneously. The middle-right shows your inventory. You can click an item here and then a loadout to add it to that loadout. The bottom-right is the "remove" button. Click it and then a loadout to remove the newest item from it.
<br><br>
Change your current loadout with 1/2/3/4 (you may have to activate "Num Lock" if using a numpad).
</div>
<script>
function Cockroach(x,y){
    this.x = x; this.y = y;
    this.tillMove = 0; this.moveCooldown = 5;
    this.state = {facing:"right",spin:"c"};
    this.update = function(){
        if(this.tillMove===0){
            movePreference = []; moveName = [];
            switch(this.state.facing){
                case "up":
                    movePreference = [[1,0],[0,-1],[-1,0],[0,1]];
                    moveName = ["right","up","left","down"];
                    break;
                case "left":
                    movePreference = [[0,-1],[-1,0],[0,1],[1,0]];
                    moveName = ["up","left","down","right"];
                    break;
                case "down":
                    movePreference = [[-1,0],[0,1],[1,0],[0,-1]];
                    moveName = ["left","down","right","up"];
                    break;
                case "right":
                    movePreference = [[0,1],[1,0],[0,-1],[-1,0]];
                    moveName = ["down","right","up","left"];
                    break;
            }
            for(tryMove=0;tryMove<movePreference.length;tryMove++){
                tryX = this.x+movePreference[tryMove][0];
                tryY = this.y+movePreference[tryMove][1];
                if(isInBounds([tryX,tryY])){
                    if(!solidMask[tryX][tryY]){
                        solidMask[this.x][this.y] = false;
                        this.x = tryX; this.y = tryY;
                        solidMask[this.x][this.y] = true;
                        this.state.facing = moveName[tryMove];
                        this.tillMove = this.moveCooldown;
                        break;
                    }
                }
            }
        }
        else{
            this.tillMove -= 1;
        }
    };
}
function Dog(x,y){
    this.x = x; this.y = y;
    this.fed = 0;
    this.tillMove = 0;
    this.state = {name:"spurred",exhaustion:0,moveCounts:[2,3,6,8,24]};
    this.randomMove = function(){
        movePreference = [[0,-1],[-1,0],[0,1],[1,0]];
        for(currentIndex=movePreference.length-1;currentIndex>-1;currentIndex--){
            randomIndex = Math.floor(Math.random()*(currentIndex+1));
            [movePreference[currentIndex],movePreference[randomIndex]] = [movePreference[randomIndex],movePreference[currentIndex]];
        }
        for(tryMove=0;tryMove<movePreference.length;tryMove++){
            tryX = this.x+movePreference[tryMove][0];
            tryY = this.y+movePreference[tryMove][1];
            if(isInBounds([tryX,tryY])){
                if((!solidMask[tryX][tryY])&&(map[tryX][tryY]!=="water")){
                    solidMask[this.x][this.y] = false;
                    this.x += movePreference[tryMove][0];
                    this.y += movePreference[tryMove][1];
                    solidMask[this.x][this.y] = true;
                    break;
                }
            }
        }
    }
    this.update = function(){
        if(this.tillMove===0){
            switch(this.state.name){
                case "spurred":
                    if(this.state.exhaustion<this.state.moveCounts.length){
                        this.randomMove();
                        this.tillMove = this.state.moveCounts[this.state.exhaustion];
                        this.state.exhaustion += 1;
                    }
                    else{
                        if(Math.random()>.4){
                            this.state = {name:"dozy"};
                        }
                        else{
                            this.state.exhaustion = 0;
                        }
                    }
                    break;
                case "dozy":
                    this.randomMove();
                    this.tillMove = 30+Math.floor(Math.random()*30);
                    if(Math.random()>.6){
                        this.state = {name:"spurred",exhaustion:0,moveCounts:[2,4,6,12,24]};
                    }
            }
        }
        else{
            this.tillMove -= 1;
        }
    }
}
function Skeleton(x,y){
    this.x = x; this.y = y;
    this.tillMove = 0; this.moveCooldown = 10;
    this.state = {name:"dormant"};
    this.update = function(){
        switch(this.state.name){
            case "dormant":
                if(Math.abs(this.x-player.x)+Math.abs(this.y-player.y)<6){
                    this.state = {name:"active"};
                }
                break;
            case "active":
                if(this.tillMove===0){
                    xDif = player.x-this.x;
                    yDif = player.y-this.y;
                    if(Math.abs(xDif)<Math.abs(yDif)){
                        if(!solidMask[this.x][this.y+Math.sign(yDif)]){
                            solidMask[this.x][this.y] = false;
                            this.y += Math.sign(yDif);
                            this.tillMove = this.moveCooldown;
                            solidMask[this.x][this.y] = true;
                        }
                        else{
                            if(!solidMask[this.x+Math.sign(xDif)][this.y]){
                                solidMask[this.x][this.y] = false;
                                this.x += Math.sign(xDif);
                                this.tillMove = this.moveCooldown;
                                solidMask[this.x][this.y] = true;
                            }
                        }
                    }
                    else{
                        if(!solidMask[this.x+Math.sign(xDif)][this.y]){
                            solidMask[this.x][this.y] = false;
                            this.x += Math.sign(xDif);
                            this.tillMove = this.moveCooldown;
                            solidMask[this.x][this.y] = true;
                        }
                        else{
                            if(!solidMask[this.x][this.y+Math.sign(yDif)]){
                                solidMask[this.x][this.y] = false;
                                this.y += Math.sign(yDif);
                                this.tillMove = this.moveCooldown;
                                solidMask[this.x][this.y] = true;
                            }
                        }
                    }
                }
                else{
                    this.tillMove -= 1;
                }
                break;
        }
    }
}
function Spider(x,y){
    this.x = x; this.y = y;
    solidMask[this.x][this.y] = true;
    this.tillMove = Math.floor(60+Math.random()*30);
    this.state = {name:"resting"};
    this.health = 3;
    this.update = function(){
        if(this.tillMove===0){
            switch(this.state.name){
                case "resting":
                    startOption = [[0,-1],[-1,0],[0,1],[1,0]];
                    finalOption = [];
                    for(tryMove=0;tryMove<startOption.length;tryMove++){
                        tryX = this.x+startOption[tryMove][0];
                        tryY = this.y+startOption[tryMove][1];
                        if(isInBounds([tryX,tryY])){
                            if(!solidMask[tryX][tryY]){
                                finalOption.push(startOption[tryMove]);
                            }
                            if((player.x===tryX)&&(player.y===tryY)){
                                takeDamage();
                                this.tillMove = Math.floor(20+Math.random()*25);
                                this.state = {name:"justAttacked"};
                            }
                        }
                    }
                    if((finalOption.length>0)&&(this.state.name==="resting")){
                        this.state = {name:"transit",direction:finalOption[Math.floor(Math.random()*finalOption.length)]};
                    }
                    break;
                case "transit":
                    tryX = this.x+this.state.direction[0];
                    tryY = this.y+this.state.direction[1];
                    if(isInBounds([tryX,tryY])&&!solidMask[tryX][tryY]){
                        solidMask[this.x][this.y] = false;
                        this.x += this.state.direction[0];
                        this.y += this.state.direction[1];
                        solidMask[this.x][this.y] = true;
                        this.tillMove = 1;
                    }
                    else{
                        this.state = {name:"resting"};
                        this.tillMove = Math.floor(20+Math.random()*25);
                    }
                    break;
                case "justAttacked":
                    this.state = {name:"resting"};
            }
        }
        else{
            this.tillMove -= 1;
        }
    }
    this.takeDamage = function(damageToTake){
        this.health -= damageToTake;
        if(!(this.health>0)){
            solidMask[this.x][this.y] = false;
            npc.splice(npc.indexOf(this),1);
        }
    }
}
function takeDamage(){
    if(player.runes.includes("armor")){
        expendItem("armor");
    }
    else{
        player.health -= 1;
        if(player.health<=0){
            clearInterval(gameClock);
            game.state.name = "gameOver";
            drawGameOver();
        }
    }
}
function isInBounds(coordinate){
    if((coordinate[0]>-1)&&(coordinate[0]<levelSize.x)&&(coordinate[1]>-1)&&(coordinate[1]<levelSize.y)){
        return true;
    }
    return false;
}
function engToChi(english){
    switch(english){
        case "armor": return "\u7532";
        case "ash": return "\u7070";
        case "axe": return "\u65A7";
        case "blink": return "\u7728";
        case "bone": return "\u9AA8";
        case "bow": return "\u5F13";
        case "building0": return "\u5EFA";
        case "building1": return "\u7B51";
        case "cockroach0": return "\u87D1";
        case "cockroach1": return "\u8782";
        case "dog": return "\u72D7";
        case "exit0": return "\u51FA";
        case "exit1": return "\u53E3";
        case "fast": return "\u5FEB";
        case "fire": return "\u706B";
        case "forest0": return "\u68EE";
        case "forest1": return "\u6797";
        case "gate": return "\u95E8";
        case "hand": return "\u624B";
        case "nothing": return "\u65E0";
        case "ice": return "\u51B0";
        case "many": return "\u591A";
        case "meat": return "\u8089";
        case "one": return "\u4E00";
        case "knife": return "\u5200";
        case "remove": return "\u9664";
        case "shield": return "\u76FE";
        case "skeleton0": return "\u9AB7";
        case "skeleton1": return "\u9AC5";
        case "spider0": return "\u8718";
        case "spider1": return "\u86DB";
        case "strong": return "\u529B";
        case "three": return "\u4E09";
        case "torch": return "\u70AC";
        case "two": return "\u4E8C";
        case "tree": return "\u6811";
        case "wall": return "\u5899";
        case "water": return "\u6C34";
    }
    return "";
}
function matToColor(material){
    switch(material){
        case "actionFill":
            return "oklch(33.73% 0.1414 261.34)";
        case "actionOutline":
            return "oklch(67.46% 0.1414 261.34)";
        case "ash":
        case "stone":
            return "gray";
        case "fire":
        case "healthOutline":
            return "red";
        case "bone":
            return "white";
        case "foliage":
            return "lightgreen";
        case "healthFill":
            return "oklch(32.4% 0.2576 29.23)";
        case "ice":
            return "white";
        case "meat":
            return "hotpink";
        case "metal":
            return "lightgray";
        case "moveFill":
            return "oklch(43.4% 0.1558 144.09)";
        case "moveOutline":
            return "oklch(86.8% 0.1558 144.09)";
        case "rune":
            return "yellow";
        case "water":
            return "cornflowerblue";
        case "wood":
            return "tan";
    }
}
function recalculateAfterResize(){
    space = Math.round(cnvs.height/viewSize.y);
    doubleSpace = Math.floor(space*2);
    halfSpace = Math.floor(space/2);
    quarterSpace = Math.floor(halfSpace/2);
    ctx.font = "" + (halfSpace-4) + "px Arial";
}
function drawLoadout(runes,centerX,CenterY){
    switch(runes.length){
        case 0:
            ctx.fillText(engToChi("nothing"),centerX,CenterY);
            break;
        case 1:
            ctx.fillText(engToChi(runes[0]),centerX,CenterY);
            break;
        case 2:
            ctx.fillText(engToChi(runes[0]),centerX,CenterY-quarterSpace);
            ctx.fillText(engToChi(runes[1]),centerX,CenterY+quarterSpace);
            break;
        case 4:
            ctx.fillText(engToChi(runes[3]),centerX-quarterSpace,CenterY+quarterSpace);
        case 3:
            ctx.fillText(engToChi(runes[0]),centerX+quarterSpace,CenterY-quarterSpace);
            ctx.fillText(engToChi(runes[1]),centerX+quarterSpace,CenterY+quarterSpace);
            ctx.fillText(engToChi(runes[2]),centerX-quarterSpace,CenterY-quarterSpace);
            break;
    }
}
function drawPlayer(viewX,viewY){
    drawX = viewX*space;
    drawY = viewY*space;
    ctx.fillStyle = "black";
    ctx.fillRect(drawX,drawY,space,space);
    ctx.strokeStyle = "white"; ctx.fillStyle = "white";
    ctx.strokeRect(drawX,drawY,space,space);
    drawLoadout(player.runes,drawX+halfSpace,drawY+halfSpace);
    invSpace = (cnvs.width-cnvs.height)/4;
    invHalfSpace = invSpace/2;
}
function drawPlay(){
    ctx.lineWidth = 1;
    ctx.font = "" + (halfSpace-4) + "px Arial";
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,cnvs.width,cnvs.height);
    for(x=0;x<viewSize.x;x++){
        for(y=0;y<viewSize.y;y++){
            drawX = x*space;
            drawY = y*space;
            lookupX = x+viewStart.x;
            lookupY = y+viewStart.y;
            switch(map[lookupX][lookupY]){
                case "ash":
                    ctx.fillStyle = matToColor("ash");
                    ctx.fillText(engToChi("ash"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "bone":
                    ctx.fillStyle = matToColor("bone");
                    ctx.fillText(engToChi("bone"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "exit":
                    ctx.setLineDash([8,8]);
                    ctx.strokeStyle = matToColor("water")
                    ctx.strokeRect(drawX,drawY,space,space);
                    ctx.setLineDash([]);
                    ctx.fillStyle = matToColor("water")
                    ctx.fillText(engToChi("exit0"),drawX+halfSpace,drawY+quarterSpace);
                    ctx.fillText(engToChi("exit1"),drawX+halfSpace,drawY+halfSpace+quarterSpace);
                    break;
                case "fire":
                    ctx.fillStyle = matToColor("fire");
                    ctx.fillText(engToChi("fire"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "gate":
                    ctx.fillStyle = matToColor("wood");
                    ctx.fillText(engToChi("gate"),drawX+halfSpace,drawY+halfSpace);
                    if(mapProp[lookupX][lookupY].closed){
                        ctx.strokeStyle = matToColor("wood");
                        ctx.strokeRect(drawX,drawY,space,space);
                    }
                    break;
                case "ice":
                    ctx.fillStyle = matToColor("ice");
                    ctx.fillText(engToChi("ice"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "tree":
                    ctx.strokeStyle = matToColor("foliage");
                    ctx.strokeRect(drawX,drawY,space,space);
                    ctx.fillStyle = matToColor("foliage");
                    ctx.fillText(engToChi("tree"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "wall":
                    ctx.strokeStyle = matToColor("stone");
                    ctx.strokeRect(drawX,drawY,space,space);
                    ctx.fillStyle = matToColor("stone");
                    ctx.fillText(engToChi("wall"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "water":
                    ctx.fillStyle = matToColor("water");
                    ctx.fillText(engToChi("water"),drawX+halfSpace,drawY+halfSpace);
                    break;
            }
            switch(item[lookupX][lookupY]){
                case "armor":
                    ctx.fillStyle = matToColor("metal");
                    ctx.fillText(engToChi("armor"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "axe":
                    ctx.fillStyle = matToColor("metal");
                    ctx.fillText(engToChi("axe"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "blink":
                    ctx.fillStyle = matToColor("rune");
                    ctx.fillText(engToChi("blink"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "bow":
                    ctx.fillStyle = matToColor("wood");
                    ctx.fillText(engToChi("bow"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "fast":
                    ctx.fillStyle = matToColor("rune");
                    ctx.fillText(engToChi("fast"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "meat":
                    ctx.fillStyle = matToColor("meat");
                    ctx.fillText(engToChi("meat"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "knife":
                    ctx.fillStyle = matToColor("metal");
                    ctx.fillText(engToChi("knife"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "shield":
                    ctx.fillStyle = matToColor("metal");
                    ctx.fillText(engToChi("shield"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "torch":
                    ctx.fillStyle = matToColor("fire");
                    ctx.fillText(engToChi("torch"),drawX+halfSpace,drawY+halfSpace);
                    break;
            }
        }
    }
    drawPlayer(player.x-viewStart.x,player.y-viewStart.y);
    for(a=0;a<npc.length;a++){
        drawX = space*(npc[a].x-viewStart.x);
        drawY = space*(npc[a].y-viewStart.y);
        if((drawX>-1)&&(drawX<viewSize.x*space)&&(drawY>-1)&&(drawY<viewSize.y*space)){
            ctx.fillStyle = "black";
            ctx.fillRect(drawX,drawY,space,space);
            switch(npc[a].constructor.name){
                case "Cockroach":
                    ctx.strokeStyle = "brown";
                    ctx.strokeRect(drawX,drawY,space,space);
                    ctx.fillStyle = "tan";
                    ctx.fillText(engToChi("cockroach0"),drawX+halfSpace,drawY+quarterSpace);
                    ctx.fillText(engToChi("cockroach1"),drawX+halfSpace,drawY+halfSpace+quarterSpace);
                    break;
                case "Dog":
                    ctx.strokeStyle = "tan";
                    ctx.strokeRect(drawX,drawY,space,space);
                    ctx.fillStyle = "tan";
                    ctx.fillText(engToChi("dog"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "Skeleton":
                    ctx.fillStyle = matToColor("bone");
                    ctx.strokeStyle = matToColor("bone");
                    if(npc[a].state.name==="dormant"){
                        ctx.fillText(engToChi("bone"),drawX+halfSpace,drawY+halfSpace);
                    }
                    else{
                        ctx.strokeRect(drawX,drawY,space,space);
                        ctx.fillText(engToChi("skeleton0"),drawX+halfSpace,drawY+quarterSpace);
                        ctx.fillText(engToChi("skeleton1"),drawX+halfSpace,drawY+halfSpace+quarterSpace);
                    }
                    break;
                case "Spider":
                    ctx.strokeStyle = "tan";
                    ctx.strokeRect(drawX,drawY,space,space);
                    ctx.fillStyle = "red";
                    ctx.fillText(engToChi("spider0"),drawX+halfSpace,drawY+quarterSpace);
                    ctx.fillText(engToChi("spider1"),drawX+halfSpace,drawY+halfSpace+quarterSpace);
                    break;
            }
        }
    }
    ctx.strokeStyle = "white";
    ctx.fillStyle = "white";
    ctx.beginPath(); ctx.moveTo(cnvs.height,0); ctx.lineTo(cnvs.height,cnvs.height); ctx.stroke();
    for(a=0;a<4;a++){
        ctx.strokeRect(cnvs.height+invHalfSpace+a*invSpace-halfSpace,invHalfSpace-halfSpace,space,space);
        drawLoadout(player.loadouts[a],cnvs.height+invSpace*a+invHalfSpace,invHalfSpace);
    }
    ctx.beginPath(); ctx.moveTo(cnvs.height,invSpace); ctx.lineTo(cnvs.width,invSpace); ctx.stroke();
    ctx.strokeRect(cnvs.width-invSpace,cnvs.height-invSpace,invSpace,invSpace);
    switch(invMode.mode){
        case "edit":
            ctx.strokeRect(cnvs.height+invHalfSpace+invSpace*(invMode.selection%4)-halfSpace,invSpace+Math.floor(invMode.selection/4)*invSpace+invHalfSpace-halfSpace,space,space);
            break;
        case "remove":
            ctx.strokeRect(cnvs.width-invHalfSpace-halfSpace,cnvs.height-invHalfSpace-halfSpace,space,space);
            break;
    }
    ctx.fillText(engToChi("remove"),cnvs.width-invHalfSpace,cnvs.height-invHalfSpace);
    for(a=0;a<Object.keys(player.inventory).length;a++){
        ctx.fillText(engToChi(Object.keys(player.inventory)[a]),cnvs.height+invHalfSpace+invSpace*(a%4),invSpace*Math.floor(a/4+1)+invHalfSpace);
    }
}
function drawPause(){
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,cnvs.width,cnvs.height);
    ctx.fillStyle = "white";
    ctx.fillText("Press 'P' to resume play.",cnvs.width/2,cnvs.height/2);
}
function drawGameOver(){
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,cnvs.width,cnvs.height);
    ctx.fillStyle = "white";
    ctx.fillText("GAME OVER (press space for main menu)",cnvs.width/2,cnvs.height/2);
}
function drawMainMenu(){
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,cnvs.width,cnvs.height);
    ctx.fillStyle = "white";
    ctx.fillText("PRESS SPACE TO START",cnvs.width/2,cnvs.height/2);
}
function fixView(){
    if(player.x<viewStart.x+viewBuffer){
        viewStart.x = Math.max(0,player.x-viewBuffer);
    }
    if(player.x>viewStart.x+viewSize.x-viewBuffer-1){
        viewStart.x = Math.min(levelSize.x-viewSize.x,player.x+viewBuffer-viewSize.x+1);
    }
    if(player.y<viewStart.y+viewBuffer){
        viewStart.y = Math.max(0,player.y-viewBuffer);
    }
    if(player.y>viewStart.y+viewSize.y-viewBuffer-1){
        viewStart.y = Math.min(levelSize.y-viewSize.y,player.y+viewBuffer-viewSize.y+1);
    }
}
function makeLevel(kind,feel){
    switch(kind){
        case "building":
            levelSize = {x:16,y:17};
            map = []; mapProp = []; item = []; solidMask = [];
            for(a=0;a<levelSize.x;a++){
                map[a] = []; mapProp[a] = []; item[a] = []; solidMask[a] = [];
                for(b=0;b<levelSize.y;b++){
                    map[a][b] = ""; mapProp[a][b] = {}; item[a][b] = null; solidMask[a][b] = false;
                    if((a===0)||(a===levelSize.x-1)||(b===0)||(b===levelSize.y-1)){
                        map[a][b] = "wall";
                    }
                }
            }
            player.x = 1; player.y = 1; map[14][15] = "exit";
            npc = [];
            break;
        case "first":
            levelSize = {x:25,y:20};
            map = []; mapProp = []; item = []; solidMask = [];
            for(a=0;a<levelSize.x;a++){
                map[a] = []; mapProp[a] = []; item[a] = []; solidMask[a] = [];
                for(b=0;b<levelSize.y;b++){
                    map[a][b] = ""; mapProp[a][b] = {}; item[a][b] = null; solidMask[a][b] = false;
                    if((a*5+b*3)%9===0){
                        map[a][b] = "tree";
                    }
                    if((a*6+b*5)%13===0){
                        map[a][b] = "wall";
                    }
                    if((a*9+b*8)%30===0){
                        map[a][b] = "water";
                    }
                }
            }
            map[3][5] = "tree"; map[3][6] = "tree"; map[2][6] = "tree"; map[1][6] = "tree";
            map[7][7] = "exit";
            map[3][2] = "gate"; mapProp[3][2] = {closed:true};
            map[3][3] = "gate"; mapProp[3][3] = {closed:false};
            map[1][1] = "ice"; map[1][2] = "ice"; map[1][3] = "ice";
            item[1][0] = "axe"; item[2][0] = "bow"; item[3][0] = "fast"; item[4][0] = "meat";
            item[5][0] = "knife"; item[6][0] = "shield"; item[7][0] = "torch"; item[8][0] = "blink";
            item[4][1] = "armor";
            player.x = 5; player.y = 3;
            npc = [new Dog(8,8), new Skeleton(10,10), new Cockroach(14,3),
                new Spider(12,11), new Spider(13,11), new Spider(14,11),
                new Spider(12,12), new Spider(13,12), new Spider(14,12)];
            break;
        case "forest":
            levelSize = {x:20,y:20};
            map = []; mapProp = []; item = []; solidMask = [];
            for(a=0;a<levelSize.x;a++){
                map[a] = []; mapProp[a] = []; item[a] = []; solidMask[a] = [];
                for(b=0;b<levelSize.y;b++){
                    map[a][b] = ""; mapProp[a][b] = {}; item[a][b] = null; solidMask[a][b] = false;
                    if((a===0)||(a===levelSize.x-1)||(b===0)||(b===levelSize.y-1)){
                        map[a][b] = "tree";
                    }
                }
            }
            player.x = 1; player.y = 1; map[18][18] = "exit";
            npc = [];
            break;
    }
    
    for(a=0;a<levelSize.x;a++){
        for(b=0;b<levelSize.y;b++){
            if(["wall","tree"].includes(map[a][b])){
                solidMask[a][b] = true;
            }
            if((map[a][b]==="gate")&&(mapProp[a][b].closed)){
                solidMask[a][b] = true;
            }
            if(["tree","gate"].includes(map[a][b])){
                mapProp[a][b].heat = 0;
            }
        }
    }
    for(a=0;a<npc.length;a++){
        solidMask[npc[a].x][npc[a].y] = true;
    }
}
function drawLevelSelect(){
    ctx.lineWidth = 3;
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,cnvs.width,cnvs.height);
    ctx.strokeStyle = "white";
    ctx.strokeRect(center.x-space,center.y-space,doubleSpace,doubleSpace);
    ctx.fillStyle = "white";
    ctx.font = "" + (space-8) + "px Arial";
    if(player.runes.length>2){
        ctx.fillText(engToChi(player.runes[0]),center.x+halfSpace,center.y-halfSpace);
        ctx.fillText(engToChi(player.runes[1]),center.x+halfSpace,center.y+halfSpace);
        ctx.fillText(engToChi(player.runes[2]),center.x-halfSpace,center.y-halfSpace);
        ctx.fillText(engToChi(player.runes[3]),center.x-halfSpace,center.y+halfSpace);
    }
    if(player.runes.length===2){
        ctx.fillText(engToChi(player.runes[0]),center.x,center.y-halfSpace);
        ctx.fillText(engToChi(player.runes[1]),center.x,center.y+halfSpace);
    }
    if(player.runes.length===1){
        ctx.fillText(engToChi(player.runes[0]),center.x,center.y);
    }
    if(player.runes.length===0){
        ctx.fillText(engToChi("hand"),center.x,center.y);
    }
    levelCenter = [{x:center.x,y:center.y-doubleSpace-space},{x:center.x-doubleSpace-space,y:center.y},{x:center.x,y:center.y+doubleSpace+space},{x:center.x+doubleSpace+space,y:center.y}]
    ctx.strokeStyle = "red";
    for(a=0;a<4;a++){
        ctx.strokeRect(levelCenter[a].x-space,levelCenter[a].y-space,doubleSpace,doubleSpace);
    }
    ctx.fillStyle = "gold";
    for(a=0;a<4;a++){
        switch(game.state.levelOption[a]){
            case "building":
                ctx.fillText(engToChi("building0"),levelCenter[a].x,levelCenter[a].y-halfSpace);
                ctx.fillText(engToChi("building1"),levelCenter[a].x,levelCenter[a].y+halfSpace);
                break;
            case "forest":
                ctx.fillText(engToChi("forest0"),levelCenter[a].x,levelCenter[a].y-halfSpace);
                ctx.fillText(engToChi("forest1"),levelCenter[a].x,levelCenter[a].y+halfSpace);
                break;
        }
    }
}
function keyDownHandler(e){
    if(e.repeat===false){
        keyTrack.push(e.key);
        if(e.key==="p"){
            switch(game.state.name){
                case "play":
                    clearInterval(gameClock);
                    game.state.name = "pause";
                    drawPause();
                    break;
                case "pause":
                    gameClock = setInterval(gameFrame,33);
                    game.state.name = "play";
                    break;
            }
        }
        if(game.state.name==="levelSelect"){
            if(["1","2","3","4"].includes(e.key)){
                switch(e.key){
                    case "1":
                        player.runes = player.loadouts[0];
                        break;
                    case "2":
                        player.runes = player.loadouts[1];
                        break;
                    case "3":
                        player.runes = player.loadouts[2];
                        break;
                    case "4":
                        player.runes = player.loadouts[3];
                        break;
                }
                applyRunes();
                drawLevelSelect();
            }
            if(["w","a","s","d"].includes(e.key)){
                switch(e.key){  
                    case "w":
                        makeLevel(game.state.levelOption[0],[]);
                        break;
                    case "a":
                        makeLevel(game.state.levelOption[1],[]);
                        break;
                    case "s":
                        makeLevel(game.state.levelOption[2],[]);
                        break;
                    case "d":
                        makeLevel(game.state.levelOption[3],[]);
                        break;
                }
                game.state.name = "play";
                fixView();
                gameClock = setInterval(gameFrame,33);
            }
        }
        if(game.state.name==="mainMenu"){
            newGame();
        }
        if(game.state.name==="gameOver"){
            game.state.name = "mainMenu";
            drawMainMenu();
        }
    }
}
function keyUpHandler(e){
    index = keyTrack.indexOf(e.key);
    if(index>-1){
        keyTrack.splice(index,1);
    }
}
function clickHandler(e){
    clickX = e.clientX-cnvs.offsetLeft;
    clickY = e.clientY-cnvs.offsetTop;
    if(clickX>cnvs.height){
        if(clickY<invSpace){
            clickLoadout = Math.floor((clickX-cnvs.height)/invSpace);
            switch(invMode.mode){
                case "edit":
                    if(player.loadouts[clickLoadout].length<4){
                        editKey = Object.keys(player.inventory)[invMode.selection];
                        if(player.inventory[editKey]>player.loadouts[clickLoadout].filter(x => x===editKey).length){
                            player.loadouts[clickLoadout].push(editKey);
                        }
                    }
                    break;
                case "remove":
                    player.loadouts[clickLoadout].pop();
                    break;
            }
            applyRunes();
        }
        else{
            testSpace = Math.floor(clickY/invSpace-1)*4+Math.floor((clickX-cnvs.height)/invSpace)%4;
            if(testSpace<Object.keys(player.inventory).length){
                invMode.mode = "edit";
                invMode.selection = testSpace;
            }
            if(testSpace===27){
                invMode.mode = "remove";
            }
        }
    }
}
function applyRunes(){
    if(player.runes.includes("blink")){
        player.moveCooldown = 8;
    }
    else{
        player.moveCooldown = 3;
    }
    player.moveCooldown -= player.runes.filter(x => x==="fast").length;
    player.moveCooldown = Math.max(player.moveCooldown,0);
    affectActionCooldown = ["axe","bow","hand","knife","meat","torch"].filter(x => player.runes.includes(x));
    relevantActionCooldowns = [];
    for(a=0;a<affectActionCooldown.length;a++){
        switch(affectActionCooldown[a]){
            case "axe": relevantActionCooldowns.push(10); break;
            case "bow": relevantActionCooldowns.push(9); break;
            case "hand": relevantActionCooldowns.push(5); break;
            case "knife": relevantActionCooldowns.push(5); break;
            case "meat": relevantActionCooldowns.push(12); break;
            case "torch": relevantActionCooldowns.push(7); break;
        }
    }
    player.actionCooldown = Math.max(...relevantActionCooldowns);
}
function expendItem(toExpend){
    player.inventory[toExpend] -= 1;
    if(player.inventory[toExpend]===0){
        delete player.inventory[toExpend];
    }
    for(a=0;a<4;a++){
        player.loadouts[a] = player.loadouts[a].filter(x => x!==toExpend);
    }
    player.runes = player.runes.filter(x => x!==toExpend);
    if(invMode.selection>Object.keys(player.inventory).length-1){
        invMode.selection -= 1;
    }
}
function gameFrame(){
    moveKeys = [keyTrack.indexOf("w"),keyTrack.indexOf("a"),keyTrack.indexOf("s"),keyTrack.indexOf("d")];
    if(player.tillMove===0){
        if(["ice"].includes(map[player.x][player.y])&&!player.inControl){
            tryX = player.x + player.recentMove.x;
            tryY = player.y + player.recentMove.y;
            if(isInBounds([tryX,tryY])){
                if(!solidMask[tryX][tryY]){
                    solidMask[player.x][player.y] = false;
                    player.x = tryX;
                    player.y = tryY;
                    solidMask[player.x][player.y] = true;
                    player.tillMove = player.moveCooldown;
                }
                else{
                    player.inControl = true;
                }
            }
        }
        else{
            if(!moveKeys.every((element) => element === -1)){
                recentMoveIndex = moveKeys.indexOf(Math.max(...moveKeys));
                possibleMove = [[0,-1],[-1,0],[0,1],[1,0]];
                if(player.runes.includes("blink")){
                    tryX = player.x;
                    tryY = player.y;
                    while(isInBounds([tryX+possibleMove[recentMoveIndex][0],tryY+possibleMove[recentMoveIndex][1]])){
                        if(!solidMask[tryX+possibleMove[recentMoveIndex][0]][tryY+possibleMove[recentMoveIndex][1]]){
                            tryX += possibleMove[recentMoveIndex][0];
                            tryY += possibleMove[recentMoveIndex][1];
                        }
                        else{
                            break;
                        }
                    }
                    solidMask[player.x][player.y] = false;
                    player.x = tryX;
                    player.y = tryY;
                    solidMask[player.x][player.y] = true;
                    player.tillMove = player.moveCooldown;
                }
                else{
                    tryX = player.x + possibleMove[recentMoveIndex][0];
                    tryY = player.y + possibleMove[recentMoveIndex][1];
                    if(isInBounds([tryX,tryY])){
                        if(!solidMask[tryX][tryY]){
                            solidMask[player.x][player.y] = false;
                            player.x = tryX;
                            player.y = tryY;
                            solidMask[player.x][player.y] = true;
                            player.tillMove = player.moveCooldown;
                            player.recentMove.x = possibleMove[recentMoveIndex][0];
                            player.recentMove.y = possibleMove[recentMoveIndex][1];
                            if(map[player.x][player.y]==="ice"){
                                player.inControl = false;
                            }
                        }
                    }
                }
                if(map[player.x][player.y]==="exit"){
                    game.state.name = "levelSelect";
                    game.state.levelOption = ["forest","building","forest","building"];
                    clearInterval(gameClock);
                    drawLevelSelect();
                }
                if(item[player.x][player.y]!==null){
                    if(player.inventory.hasOwnProperty(item[player.x][player.y])){
                        player.inventory[item[player.x][player.y]] += 1;
                    }
                    else{
                        player.inventory[item[player.x][player.y]] = 1;
                    }
                    item[player.x][player.y] = null;
                }
                fixView();
            }
        }
    }
    else{
        player.tillMove -= 1;
    }
    loadoutKeys = [keyTrack.indexOf("1"),keyTrack.indexOf("2"),keyTrack.indexOf("3"),keyTrack.indexOf("4")];
    if(!loadoutKeys.every((element) => element === -1)){
        recentLoadoutIndex = loadoutKeys.indexOf(Math.max(...loadoutKeys));
        player.runes = player.loadouts[recentLoadoutIndex];
        applyRunes();
    }
    actionKeys = [keyTrack.indexOf("ArrowUp"),keyTrack.indexOf("ArrowLeft"),keyTrack.indexOf("ArrowDown"),keyTrack.indexOf("ArrowRight")];
    if(player.tillAction===0){
        if(!actionKeys.every((element) => element === -1)){
            recentActionIndex = actionKeys.indexOf(Math.max(...actionKeys));
            actionX = 0; actionY = 0;
            switch(recentActionIndex){
                case 0:
                    actionY = -1;
                    break;
                case 1:
                    actionX = -1;
                    break;
                case 2:
                    actionY = 1;
                    break;
                case 3:
                    actionX = 1;
                    break;
            }
            if(player.runes.includes("axe")){
                if(["tree","gate"].includes(map[player.x+actionX][player.y+actionY])){
                    map[player.x+actionX][player.y+actionY] = "grass";
                    mapProp[player.x+actionX][player.y+actionY] = {};
                    solidMask[player.x+actionX][player.y+actionY] = false;
                    player.tillAction = player.actionCooldown;
                }
            }
            if(player.runes.includes("hand")){
                if(map[player.x+actionX][player.y+actionY]==="gate"){
                    mapProp[player.x+actionX][player.y+actionY].closed = !mapProp[player.x+actionX][player.y+actionY].closed;
                    solidMask[player.x+actionX][player.y+actionY] = !solidMask[player.x+actionX][player.y+actionY];
                    player.tillAction = player.actionCooldown;
                }
            }
            if(player.runes.includes("knife")){
                for(a=0;a<npc.length;a++){
                    if((npc[a].x===player.x+actionX)&&(npc[a].y===player.y+actionY)){
                        npc[a].takeDamage(1);
                    }
                }
            }
            if(player.runes.includes("torch")){
                if(["tree","gate"].includes(map[player.x+actionX][player.y+actionY])){
                    
                    switch(map[player.x+actionX][player.y+actionY]){
                        case "tree":
                            mapProp[player.x+actionX][player.y+actionY] = {burnLeft:22};
                            break;
                        case "gate":
                            mapProp[player.x+actionX][player.y+actionY] = {burnLeft:18};
                            break;
                    }
                    map[player.x+actionX][player.y+actionY] = "fire";
                    solidMask[player.x+actionX][player.y+actionY] = false;
                    player.tillAction = player.actionCooldown;
                }
            }
            if(player.runes.includes("meat")){
                match = npc.findIndex(test => ((test.x===player.x+actionX)&&(test.y===player.y+actionY)));
                if(match>-1){
                    npc[match].fed += 1;
                    expendItem("meat");
                    player.tillAction = player.actionCooldown;
                }
            }
        }
    }
    else{
        player.tillAction -= 1;
    }
    for(x=0;x<levelSize.x;x++){
        for(y=0;y<levelSize.y;y++){
            if(map[x][y]==="fire"){
                if(mapProp[x][y].burnLeft>0){
                    mapProp[x][y].burnLeft -= 1;
                    if(y-1>-1){
                        if(mapProp[x][y-1].hasOwnProperty("heat")){
                            if(mapProp[x][y-1].heat===8){
                                map[x][y-1] = "fire"; mapProp[x][y-1] = {burnLeft:20};
                            }
                            else{
                                mapProp[x][y-1].heat += 1;
                            }
                        }
                    }
                    if(x-1>-1){
                        if(mapProp[x-1][y].hasOwnProperty("heat")){
                            if(mapProp[x-1][y].heat===8){
                                map[x-1][y] = "fire"; mapProp[x-1][y] = {burnLeft:20};
                            }
                            else{
                                mapProp[x-1][y].heat += 1;
                            }
                        }
                    }
                    if(y+1<levelSize.y-1){
                        if(mapProp[x][y+1].hasOwnProperty("heat")){
                            if(mapProp[x][y+1].heat===8){
                                map[x][y+1] = "fire"; mapProp[x][y+1] = {burnLeft:20};
                            }
                            else{
                                mapProp[x][y+1].heat += 1;
                            }
                        }
                    }
                    if(x+1<levelSize.x-1){
                        if(mapProp[x+1][y].hasOwnProperty("heat")){
                            if(mapProp[x+1][y].heat===8){
                                map[x+1][y] = "fire"; mapProp[x+1][y] = {burnLeft:20};
                            }
                            else{
                                mapProp[x+1][y].heat += 1;
                            }
                        }
                    }
                }
                else{
                    mapProp[x][y] = {};
                    map[x][y] = "ash";
                    solidMask[x][y] = false;
                }
            }
        }
    }
    for(a=0;a<npc.length;a++){
        npc[a].update();
    }
    if(game.state.name==="play"){
        drawPlay();
    }
}
function newGame(){
    player = {runes:[],loadouts:[["knife","fast"],[],[],[]],inventory:{"hand":1,"fast":2},
        x:5,y:3,
        tillMove:0,moveCooldown:3,recentMove:{x:0,y:0},inControl:true,
        tillAction:0,actionCooldown:6,
        health:3,healthMax:3};
    player.runes = player.loadouts[0]; applyRunes();
    makeLevel("first",[]);
    game.state = {name:"play",level:0};
    fixView();
    gameClock = setInterval(gameFrame,33);
}
window.document.addEventListener("keydown",keyDownHandler);
window.document.addEventListener("keyup",keyUpHandler);
window.document.addEventListener("click",clickHandler);
keyTrack = [];
cnvs = document.getElementById("theCanvas"); cnvs.focus(); ctx = cnvs.getContext("2d");
ctx.textBaseline = "middle"; ctx.textAlign = "center"; ctx.lineWidth = 1.5;
space = 6; halfSpace = 5; quarterSpace = 4; doubleSpace = 3; center = {x:cnvs.width/2,y:cnvs.height/2};
viewBuffer = 5;
invMode = {mode:"remove",selection:0};
viewSize = {x:15,y:15};
viewStart = {x:0,y:0};
game = {state:{name:"mainMenu"}};
recalculateAfterResize();
drawMainMenu();
</script>
</html>