<html>
<canvas id="theCanvas" width="900" height="600" style="border: 1px solid black"></canvas>
<div id="theDiv">
Move with WASD keys.
<br><br>
Perform actions with arrow keys (once you have items loaded).
<br><br>
The right side of the screen lets you manage which items you're using. The top-right shows your "loadouts" - sets of up to four items you can use simultaneously. The middle-right shows your inventory. You can click an item here and then a loadout to add it to that loadout. The bottom-right is the "remove" button. Click it and then a loadout to remove the newest item from it.<br>
<br><br>
Change your current loadout with 1/2/3/4 (you may have to activate "Num Lock" if using a numpad).
</div>
<script>
function Dog(x,y){
    this.x = x;
    this.y = y;
    this.tillMove = 0;
    this.state = {name:"spurred",exhaustion:0,moveCounts:[2,3,6,8,24]};
    this.randomMove = function(){
        movePreference = [[0,-1],[-1,0],[0,1],[1,0]];
        for(currentIndex=movePreference.length-1;currentIndex>-1;currentIndex--){
            randomIndex = Math.floor(Math.random()*(currentIndex+1));
            [movePreference[currentIndex],movePreference[randomIndex]] = [movePreference[randomIndex],movePreference[currentIndex]];
        }
        for(tryMove=0;tryMove<movePreference.length;tryMove++){
            tryX = this.x+movePreference[tryMove][0];
            tryY = this.y+movePreference[tryMove][1];
            if((tryX>-1)&&(tryX<levelSize.x)&&(tryY>-1)&&(tryY<levelSize.y)){
                if(!solidMask[tryX][tryY]){
                    solidMask[this.x][this.y] = false;
                    this.x += movePreference[tryMove][0];
                    this.y += movePreference[tryMove][1];
                    solidMask[this.x][this.y] = true;
                    break;
                }
            }
        }
    }
    this.update = function(){
        if(this.tillMove===0){
            switch(this.state.name){
                case "spurred":
                    if(this.state.exhaustion<this.state.moveCounts.length){
                        this.randomMove();
                        this.tillMove = this.state.moveCounts[this.state.exhaustion];
                        this.state.exhaustion += 1;
                    }
                    else{
                        if(Math.random()>.7){
                            this.state = {name:"dozy"};
                        }
                        else{
                            this.state.exhaustion = 0;
                        }
                    }
                    break;
                case "dozy":
                    this.randomMove();
                    this.tillMove = 30+Math.floor(Math.random()*30);
                    if(Math.random()>.7){
                        this.state = {name:"spurred",exhaustion:0,moveCounts:[2,4,6,12,24]};
                    }
            }
        }
        else{
            this.tillMove -= 1;
        }
    }
}
function engToChi(english){
    switch(english){
        case "ash": return "\u7070";
        case "axe": return "\u65A7";
        case "bow": return "\u5F13";
        case "dog": return "\u72D7";
        case "fast": return "\u5FEB";
        case "fire": return "\u706B";
        case "nothing": return "\u65E0";
        case "ice": return "\u51B0";
        case "many": return "\u591A";
        case "meat": return "\u8089";
        case "one": return "\u4E00";
        case "knife": return "\u5200";
        case "remove": return "\u9664";
        case "shield": return "\u76FE";
        case "strong": return "\u529B";
        case "three": return "\u4E09";
        case "torch": return "\u70AC";
        case "two": return "\u4E8C";
        case "tree": return "\u6811";
        case "wall": return "\u5899";
        case "water": return "\u6C34";
    }
    return "";
}
function recalculateAfterResize(){
    space = Math.round(cnvs.height/viewSize.y);
    halfSpace = Math.floor(space/2);
    quarterSpace = Math.floor(halfSpace/2);
    ctx.font = "" + (halfSpace-4) + "px Arial";
}
function drawLoadout(runes,centerX,CenterY){
    switch(runes.length){
        case 0:
            ctx.fillText(engToChi("nothing"),centerX,CenterY);
            break;
        case 1:
            ctx.fillText(engToChi(runes[0]),centerX,CenterY);
            break;
        case 2:
            ctx.fillText(engToChi(runes[0]),centerX,CenterY-quarterSpace);
            ctx.fillText(engToChi(runes[1]),centerX,CenterY+quarterSpace);
            break;
        case 4:
            ctx.fillText(engToChi(runes[3]),centerX-quarterSpace,CenterY+quarterSpace);
        case 3:
            ctx.fillText(engToChi(runes[0]),centerX+quarterSpace,CenterY-quarterSpace);
            ctx.fillText(engToChi(runes[1]),centerX+quarterSpace,CenterY+quarterSpace);
            ctx.fillText(engToChi(runes[2]),centerX-quarterSpace,CenterY-quarterSpace);
            break;
    }
}
function drawPlayer(viewX,viewY){
    drawX = viewX*space;
    drawY = viewY*space;
    ctx.fillStyle = "black";
    ctx.fillRect(drawX,drawY,space,space);
    ctx.strokeStyle = "white"; ctx.fillStyle = "white";
    ctx.strokeRect(drawX,drawY,space,space);
    drawLoadout(player.runes,drawX+halfSpace,drawY+halfSpace);
    invSpace = (cnvs.width-cnvs.height)/4;
    invHalfSpace = invSpace/2;
}
function drawPlay(){
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,cnvs.width,cnvs.height);
    for(x=0;x<viewSize.x;x++){
        for(y=0;y<viewSize.y;y++){
            drawX = x*space;
            drawY = y*space;
            lookupX = x+viewStart.x;
            lookupY = y+viewStart.y;
            switch(map[lookupX][lookupY]){
                case "ash":
                    ctx.fillStyle = "gray";
                    ctx.fillText(engToChi("ash"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "fire":
                    ctx.fillStyle = "red";
                    ctx.fillText(engToChi("fire"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "tree":
                    ctx.strokeStyle = "lightgreen";
                    ctx.strokeRect(drawX,drawY,space,space);
                    ctx.fillStyle = "lightgreen";
                    ctx.fillText(engToChi("tree"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "wall":
                    ctx.strokeStyle = "gray";
                    ctx.strokeRect(drawX,drawY,space,space);
                    ctx.fillStyle = "gray";
                    ctx.fillText(engToChi("wall"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "water":
                    ctx.fillStyle = "cornflowerblue";
                    ctx.fillText(engToChi("water"),drawX+halfSpace,drawY+halfSpace);
                    break;
            }
            switch(item[lookupX][lookupY]){
                case "axe":
                    ctx.fillStyle = "lightgray";
                    ctx.fillText(engToChi("axe"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "bow":
                    ctx.fillStyle = "tan";
                    ctx.fillText(engToChi("bow"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "knife":
                    ctx.fillStyle = "lightgray";
                    ctx.fillText(engToChi("knife"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "shield":
                    ctx.fillStyle = "lightgray";
                    ctx.fillText(engToChi("shield"),drawX+halfSpace,drawY+halfSpace);
                    break;
                case "torch":
                    ctx.fillStyle = "red";
                    ctx.fillText(engToChi("torch"),drawX+halfSpace,drawY+halfSpace);
                    break;
            }
        }
    }
    drawPlayer(player.x-viewStart.x,player.y-viewStart.y);
    for(a=0;a<npc.length;a++){
        drawX = space*(npc[a].x-viewStart.x);
        drawY = space*(npc[a].y-viewStart.y);
        if((drawX>0)&&(drawX<viewSize.x*space)&&(drawY>0)&&(drawY<viewSize.y*space)){
            switch(npc[a].constructor.name){
            case "Dog":
                ctx.fillStyle = "black";
                ctx.fillRect(drawX,drawY,space,space);
                ctx.strokeStyle = "tan";
                ctx.strokeRect(drawX,drawY,space,space);
                ctx.fillStyle = "tan";
                ctx.fillText(engToChi("dog"),drawX+halfSpace,drawY+halfSpace);
            }
        }
    }
    ctx.strokeStyle = "white";
    ctx.fillStyle = "white";
    ctx.beginPath(); ctx.moveTo(cnvs.height,0); ctx.lineTo(cnvs.height,cnvs.height); ctx.stroke();
    for(a=0;a<4;a++){
        ctx.strokeRect(cnvs.height+invHalfSpace+a*invSpace-halfSpace,invHalfSpace-halfSpace,space,space);
        drawLoadout(player.loadouts[a],cnvs.height+invSpace*a+invHalfSpace,invHalfSpace);
    }
    ctx.beginPath(); ctx.moveTo(cnvs.height,invSpace); ctx.lineTo(cnvs.width,invSpace); ctx.stroke();
    ctx.strokeRect(cnvs.width-invSpace,cnvs.height-invSpace,invSpace,invSpace);
    switch(invMode.mode){
        case "edit":
            ctx.strokeRect(cnvs.height+invHalfSpace+invSpace*invMode.selection-halfSpace,invSpace+invHalfSpace-halfSpace,space,space);
            break;
        case "remove":
            ctx.strokeRect(cnvs.width-invHalfSpace-halfSpace,cnvs.height-invHalfSpace-halfSpace,space,space);
            break;
    }
    ctx.fillText(engToChi("remove"),cnvs.width-invHalfSpace,cnvs.height-invHalfSpace);
    for(a=0;a<Object.keys(player.inventory).length;a++){
        ctx.fillText(engToChi(Object.keys(player.inventory)[a]),cnvs.height+invHalfSpace+invSpace*(a%4),invSpace*Math.floor(a/4+1)+invHalfSpace);
    }
}
function keyDownHandler(e){
    if(e.repeat===false){
        keyTrack.push(e.key);
    }
    
}
function keyUpHandler(e){
    index = keyTrack.indexOf(e.key);
    if(index>-1){
        keyTrack.splice(index,1);
    }
}
function clickHandler(e){
    clickX = e.clientX-cnvs.offsetLeft;
    clickY = e.clientY-cnvs.offsetTop;
    if(clickX>cnvs.height){
        if(clickY<invSpace){
            clickLoadout = Math.floor((clickX-cnvs.height)/invSpace);
            switch(invMode.mode){
                case "edit":
                    if(player.loadouts[clickLoadout].length<4){
                        editKey = Object.keys(player.inventory)[invMode.selection];
                        if(player.inventory[editKey]>player.loadouts[clickLoadout].filter(x => x===editKey).length){
                            player.loadouts[clickLoadout].push(editKey);
                        }
                    }
                    break;
                case "remove":
                    player.loadouts[clickLoadout].pop();
                    break;
            }
        }
        else{
            testSpace = Math.floor(clickY/invSpace-1)*4+Math.floor((clickX-cnvs.height)/invSpace)%4;
            if(testSpace<Object.keys(player.inventory).length){
                invMode.mode = "edit";
                invMode.selection = testSpace;
            }
            if(testSpace===27){
                invMode.mode = "remove";
            }
        }
    }
}
window.document.addEventListener("keydown",keyDownHandler);
window.document.addEventListener("keyup",keyUpHandler);
window.document.addEventListener("click",clickHandler);
keyTrack = [];
cnvs = document.getElementById("theCanvas");
cnvs.focus();
ctx = cnvs.getContext("2d");
ctx.textBaseline = "middle";
ctx.textAlign = "center";
ctx.lineWidth = 1.5;
player = {runes:[],loadouts:[[],[],[],[]],inventory:{},x:5,y:3,tillMove:0,moveCooldown:3};
invMode = {mode:"remove",selection:0};
space = 6; halfSpace = 5; quarterSpace = 4;
levelSize = {x:25,y:20};
viewSize = {x:15,y:15};
viewStart = {x:0,y:0};
viewBuffer = 5;
map = []; mapProp = [];
item = [];
for(x=0;x<levelSize.x;x++){
    map[x] = []; mapProp[x] = [];
    item[x] = [];
    for(y=0;y<levelSize.y;y++){
        map[x][y] = "grass"; mapProp[x][y] = {};
        if((x*5+y*3)%9===0){
            map[x][y] = "tree";
        }
        if((x*6+y*5)%13===0){
            map[x][y] = "wall";
        }
        if((x*9+y*8)%30===0){
            map[x][y] = "water";
        }
        item[x][y] = null;
    }
}
map[3][5] = "tree"; map[3][6] = "tree"; map[2][6] = "tree"; map[1][6] = "tree";
item[2][2] = "torch"; item[2][4] = "torch";
item[4][1] = "knife";
item[5][0] = "bow";
item[6][1] = "axe";
item[6][3] = "shield";
solidMask = [];
for(x=0;x<levelSize.x;x++){
    solidMask[x] = [];
    for(y=0;y<levelSize.y;y++){
        if(["tree","wall"].includes(map[x][y])){
            solidMask[x][y] = true;
        }
        else{
            solidMask[x][y] = false;
        }
        if(map[x][y]==="tree"){
            mapProp[x][y] = {heat:0};
        }
    }
}
player.runes = player.loadouts[0];
npc = [new Dog(8,8)];
for(a=0;a<npc.length;a++){
    solidMask[npc[a].x][npc[a].y] = true;
}
recalculateAfterResize();
setInterval(function(){
    moveKeys = [keyTrack.indexOf("w"),keyTrack.indexOf("a"),keyTrack.indexOf("s"),keyTrack.indexOf("d")];
    if(player.tillMove===0){
        
        //Handle movement
        if(!moveKeys.every((element) => element === -1)){
            //alert(moveKeys.toString());
            recentMoveIndex = moveKeys.indexOf(Math.max(...moveKeys));
            possibleMove = [[0,-1],[-1,0],[0,1],[1,0]];
            tryX = player.x + possibleMove[recentMoveIndex][0];
            tryY = player.y + possibleMove[recentMoveIndex][1];
            //alert(tryX+","+tryY);
            if((tryX>-1)&&(tryX<levelSize.x)&&(tryY>-1)&&(tryY<levelSize.y)){
                if(!solidMask[tryX][tryY]){
                    solidMask[player.x][player.y] = false;
                    player.x = tryX;
                    player.y = tryY;
                    solidMask[player.x][player.y] = true;
                    player.tillMove = player.moveCooldown;
                }
            }
            if(item[player.x][player.y]!==null){
                if(player.inventory.hasOwnProperty(item[player.x][player.y])){
                    player.inventory[item[player.x][player.y]] += 1;
                }
                else{
                    player.inventory[item[player.x][player.y]] = 1;
                }
                item[player.x][player.y] = null;
            }
            //Adjust viewStart based on new player position
            if(player.x<viewStart.x+viewBuffer){
                viewStart.x = Math.max(0,player.x-viewBuffer);
            }
            if(player.x>viewStart.x+viewSize.x-viewBuffer-1){
                viewStart.x = Math.min(levelSize.x-viewSize.x,player.x+viewBuffer-viewSize.x+1);
            }
            if(player.y<viewStart.y+viewBuffer){
                viewStart.y = Math.max(0,player.y-viewBuffer);
            }
            if(player.y>viewStart.y+viewSize.y-viewBuffer-1){
                viewStart.y = Math.min(levelSize.y-viewSize.y,player.y+viewBuffer-viewSize.y+1);
            }
        }
    }
    else{
        player.tillMove -= 1;
    }
    loadoutKeys = [keyTrack.indexOf("1"),keyTrack.indexOf("2"),keyTrack.indexOf("3"),keyTrack.indexOf("4")];
    if(!loadoutKeys.every((element) => element === -1)){
        recentLoadoutIndex = loadoutKeys.indexOf(Math.max(...loadoutKeys));
        player.runes = player.loadouts[recentLoadoutIndex];
    }
    actionKeys = [keyTrack.indexOf("ArrowUp"),keyTrack.indexOf("ArrowLeft"),keyTrack.indexOf("ArrowDown"),keyTrack.indexOf("ArrowRight")];
    if(!actionKeys.every((element) => element === -1)){
        recentActionIndex = actionKeys.indexOf(Math.max(...actionKeys));
        actionX = 0; actionY = 0;
        switch(recentActionIndex){
            case 0:
                actionY = -1;
                break;
            case 1:
                actionX = -1;
                break;
            case 2:
                actionY = 1;
                break;
            case 3:
                actionX = 1;
                break;
        }
        if(player.runes.includes("torch")){
            if(map[player.x+actionX][player.y+actionY]==="tree"){
                map[player.x+actionX][player.y+actionY] = "fire";
                mapProp[player.x+actionX][player.y+actionY] = {burnLeft:20};
                solidMask[player.x+actionX][player.y+actionY] = false;
            }
        }
        if(player.runes.includes("axe")){
            if(map[player.x+actionX][player.y+actionY]==="tree"){
                map[player.x+actionX][player.y+actionY] = "grass";
                mapProp[player.x+actionX][player.y+actionY] = {};
                solidMask[player.x+actionX][player.y+actionY] = false;
            }
        }
    }
    for(x=0;x<levelSize.x;x++){
        for(y=0;y<levelSize.y;y++){
            if(map[x][y]==="fire"){
                if(mapProp[x][y].burnLeft>0){
                    mapProp[x][y].burnLeft -= 1;
                    if(y-1>-1){
                        if(mapProp[x][y-1].hasOwnProperty("heat")){
                            if(mapProp[x][y-1].heat===8){
                                map[x][y-1] = "fire"; mapProp[x][y-1] = {burnLeft:20};
                            }
                            else{
                                mapProp[x][y-1].heat += 1;
                            }
                        }
                    }
                    if(x-1>-1){
                        if(mapProp[x-1][y].hasOwnProperty("heat")){
                            if(mapProp[x-1][y].heat===8){
                                map[x-1][y] = "fire"; mapProp[x-1][y] = {burnLeft:20};
                            }
                            else{
                                mapProp[x-1][y].heat += 1;
                            }
                        }
                    }
                    if(y+1<levelSize.y-1){
                        if(mapProp[x][y+1].hasOwnProperty("heat")){
                            if(mapProp[x][y+1].heat===8){
                                map[x][y+1] = "fire"; mapProp[x][y+1] = {burnLeft:20};
                            }
                            else{
                                mapProp[x][y+1].heat += 1;
                            }
                        }
                    }
                    if(x+1<levelSize.x-1){
                        if(mapProp[x+1][y].hasOwnProperty("heat")){
                            if(mapProp[x+1][y].heat===8){
                                map[x+1][y] = "fire"; mapProp[x+1][y] = {burnLeft:20};
                            }
                            else{
                                mapProp[x+1][y].heat += 1;
                            }
                        }
                    }
                }
                else{
                    mapProp[x][y] = {};
                    map[x][y] = "ash";
                    solidMask[x][y] = false;
                }
            }
        }
    }
    for(a=0;a<npc.length;a++){
        npc[a].update();
    }
    drawPlay();
},33);
</script>
</html>